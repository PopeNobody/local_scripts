#!/usr/bin/perl
 
$|++;
use strict;
use warnings;

our($dry_run, $debug, $link, $replace);
($dry_run, $debug, $link, $replace) = qw( 1 0 1 1 );


sub handle_args();
sub debug {
	print STDERR @_, "\n" if $debug;
};
sub xrename($$) {
    my $from=shift or die;
    my $to=shift or die;
    die "too many args" if @_;
    if($dry_run) {
        debug("will not rename ($from) to ($to)");
        return $from;
    }else{
				rename($from,$to) or die "rename:$from,$to:$!";
        return $to;
    };
};
sub fix_name($)
{
	for(shift)
  {
    return $_ unless s/[^.a-zA-Z0-9-]/_/g;
    use Data::Dumper;
    s/__+/_/g;
    return $_;
	};
  die "no arg for fix_name!";
};
sub handle_args()
{
  local (@_)=splice(@ARGV);
  for(@_)
  {  
    if (/^-y$/){
      $dry_run=0;
    } elsif ( /^-d/ ) {
      $debug=1;
    } else {
      push(@ARGV,$_);
    };
  };
};
sub main
{
  handle_args;
  open(STDERR,">&STDOUT") if $dry_run;
  $debug=1 if $dry_run;
  my @dir;
  push(@dir, @ARGV || $ENV{PWD} );
  my @todo;
  $\="\n";
  while(@dir) {
    my $dir=shift @dir;
    my @dents=do{
      opendir(my $dh, $dir) || die "open:$dir:$!";
      local @_=readdir($dh) or die "readdir:$dir:$!";
      closedir($dh) or die "closedir:$dh:$!";
      @_ = grep { !m{^\.\.?$} } @_;
      @_;
    };
    for(@dents) {
      my $orig=$_;
      my $dest=fix_name($_);
      my $forig="$dir/$orig";
      my $fdest="$dir/$dest";
      if( -d "$forig" ) {
        push(@dir,"$forig");
      };
      next if $orig eq $dest;
      next if -l $forig && readlink($forig) eq $dest;
      if( -e $dest ) {
        warn "will not clobber $dest with $orig\n";
        next;
      };
      xrename($forig,$fdest);
    };
  };
};
main;
