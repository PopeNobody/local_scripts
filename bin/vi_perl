#!/usr/bin/perl

use strict;
use warnings;
use autodie qw(:all);
use autodie qw(fork);
use File::stat;
$|++;

BEGIN {
  $\="\n";
  #  print STDERR "$$ started @ARGV";
};
END {
  #  print STDERR "$$ ended";
};
open(STDIN,"</dev/null");
use IO::Pipe;
my $out = new IO::Pipe;
my $err = new IO::Pipe;
@ARGV = ( "-e", '$\="\n"; print for glob("*");' ) unless @ARGV;
my $script=shift;
if( $script ne "-e" ) {  
  if( ! -f $script ) {
    use Data::Dumper;

    for( map { join('/',$_,$script) } split(/:/, $ENV{PATH})) {
      print Dumper( $_, lstat($_) );
      next unless -e _;
      $script=$_;
    };
  };

};

if( !fork ) {
  open(STDOUT,">&".fileno($out->writer)) or die;
  open(STDERR,">&".fileno($err->writer)) or die;
  close($out);
  close($err);
  exec "perl", $script, @ARGV;
  die "failed!";
};
use IO::Select;
my $sel = new IO::Select;
my $out_buf="";
my $err_buf="";
$sel->add( [ $out->reader(), \$out_buf, 0 ] );
$sel->add( [ $err->reader(), \$err_buf, 1 ] );
while($sel->handles){
  my @can=$sel->can_read;
  for(@can)
  {
    my ($pipe,$ref,$stream);
    ( $pipe, $ref, $stream ) = @$_;
    local (*_)=$ref;
    my $res=sysread($pipe,$_,1,length);
    if(!defined($res)) {
      die "sysread:$!";
    } elsif ( !$res ) {
      $sel->remove($pipe);
      close($pipe) or die "close:$!";
      $_="$_\n" if length($$ref);
    };
    next unless chomp;
    if($stream && s{ at (\S+) line (\d+)\.*}{})
    {
      my ($file,$line) = ($1,$2);
      s{^\t(.*)called\s*$}{called from $1};
      print STDERR "$file:$line: msg $_";
    } else {
      print STDOUT "$_";
    };
    $_="";
  };
};
